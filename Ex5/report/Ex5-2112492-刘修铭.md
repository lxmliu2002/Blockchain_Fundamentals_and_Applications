# 	<center>**区块链基础及应用实验报告**</center>

## <center>**Ex5**</center>

## <center> **网络空间安全学院 信息安全专业**</center>

## <center> **2112492 刘修铭 0939**</center>

https://github.com/lxmliu2002/Blockchain_Fundamentals_and_Applications

# 一、实验要求

使用 Solidity 和 web3.js 在以太坊（Ethereum）上实现一个复杂的去中心化应用程序（DApp），编写一个智能合约和访问它的用户客户端，学习 DApp 的“全栈”开发。



# 二、实验过程

## （一）前期准备

按照实验手册说明，安装 Node.js、 Ganache CLI 等工具。

学习使用 REMIX 进行 Solidity 语言智能合约的编写。

使用 IDE 修改 scriots.js 构建客户端。

## （二）智能合约

本项目中，使用 Solidity 语言在 REMIX 平台上完成了智能合约的编写。

本项目的智能合约要求 Solidity 编译器的版本至少为 0.4.0。

```solidity
pragma solidity >=0.4.0;
```

为了能够轻松地追踪和管理不同地址之间的债务情况，定义了如下数据结构：

* 定义了 Debt 结构体，其 amount 属性，用于表示两个地址（债务主体）间的债务金额；

  ```solidity
  struct Debt { uint32 amount; }
  ```

* 定义了一个映射结构，用于表示 $A \xrightarrow{Debt} B$ 的债务图关系。

  * 使用 `Debts[debtor][creditor]` 得到一个 `Debt` 结构体，表示债务人 `debtor` 欠债权人 `creditor` 的债务情况；
  * 为了确保合约的安全性，确保映射中的数据只能在合约内部进行修改和查询，使用 `internal`  关键字予以实现。

  ```solidity
  mapping(address => mapping(address => Debt)) internal Debts;
  ```

接着实现了 **lookup** 函数，用于查询返回债务人欠债权人的金额。

*  `public`表示可以从合约外部调用，而 `view` 关键字表示该函数仅作查询使用，不会修改合约的状态。

```solidity
function lookup(address debtor, address creditor) public view returns (uint32 ret) {
    ret = Debts[debtor][creditor].amount;
}
```

接着实现了 **add_IOU** 函数，为调用者添加一个欠条，如果已经欠钱，金额会增加。金额必须为正数。

* 按照实验要求，进行基本检查：

  * 为防止自己清除自己债务等操作，要求债务人与债权人不为同一人。

    ```solidity
    require(creditor != debtor, "Debtor and Creditor cannot be the same one!");
    ```

  * 同时，为防止恶意刷款，要求金额必须为正数。

    ```solidity
    require(amount > 0, "Amount must be greater than 0!");
    ```

* 接着按照 min_Amount 的情况进行讨论。min_Amount 表示当前路径中的最小金额。

  * 当 min_Amount 为 0 时，直接将债务金额增加上新的借款金额，然后返回。

    ```solidity
    if (min_Amount == 0)
    {
        debt.amount += amount;
        return;
    }
    ```

  * 当其不为 0 时。

    * 首先进行基本检查，确保债务金额和新增的借款金额总和不小于最小金额；验证传入的路径是否正确，即路径的第一个地址应该是债权人，最后一个地址应该是债务人。

      ```solidity
      require((debt.amount + amount) >= min_Amount, "The amount is smaller than min_Amount!");
      require(creditor == path[0] && debtor == path[path.length - 1], "The path is wrong!");
      ```

    * 接着遍历路径中的每一对地址，检查债务是否存在，并且是否足够扣除最小金额。如果存在，就扣除相应的最小金额。

      ```solidity
      for(uint256 i = 0; i < path.length - 1; i++)
      {
          require(Debts[path[i]][path[i + 1]].amount != 0, "The debt is not exist!");
          require(Debts[path[i]][path[i + 1]].amount >= min_Amount, "The debt does not enough to deduct the min_Amount!");
          Debts[path[i]][path[i + 1]].amount -= min_Amount;
      }
      ```

    * 最后更新债务信息。

      ```solidity
      debt.amount += amount - min_Amount;
      ```

## （三）客户端

基于已编写的智能合约的后端代码，实现了如下客户端前端的编写。

* 首先将编写好的智能合约在 REMIX 平台中编译并部署，将生成的 ABI 与部署的合约地址填写到 scriots.js 客户端代码的指定位置。

* 接着实现了    函数

* 然后是 getUsers()  函数，用于返回一个地址列表。

  ```javascript
  
  ```

* 实现了 getTotalOwed(user) 函数，用于返回指定用户所欠的总金额。

  ```javascript
  
  ```

* 实现了 getLastActive(user)  函数，用于返回该用户上次记录活动的 UNIX 时间戳。

  ```javascript
  
  ```

* 最后实现了 add_IOU(creditor, amount) 函数，用于向合约中添加一个债务记录。

  ```javascript
  
  ```



# 三、实验结果

完成好智能合约的部署，打开 index.html，可以看到如下初始化页面。可以看到，每个地址的总欠款数为 `0`（缺省值），上次调用时间为  `1/1/1970, 8:00:00 AM`（缺省值）。







选择第一个用户，向第二个用户添加欠款 1，点击 `Add IOU`，可以看到，`Users` 列表中多了这两个用户的地址，用户 1 的欠款数变为 1，用户 1 与用户 2 的最近调用时间变为            **电话撒谎发哎浪费粮食ID是放假啊**





选择第二个用户，向第三个用户添加欠款 2，点击 `Add IOU`，可以看到，`Users` 列表中多了这两个用户的地址，用户 2 的欠款数变为 2，用户 2 与用户 3 的最近调用时间变为            **电话撒谎发哎浪费粮食ID是放假啊**





选择第三个用户，向第一个用户添加欠款 3，点击 `Add IOU`，可以看到，用户 1 的欠款数变为 0，用户 2 的欠款数变为 1，用户 3 的欠款数变为 2，用户 3 与用户 1 的最近调用时间变为            **电话撒谎发哎浪费粮食ID是放假啊**



上述过程说明，最初的债务情况形成的循环得到解决，应用程序的功能得到验证。

















